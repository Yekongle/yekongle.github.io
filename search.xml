<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java常见设计模式]]></title>
    <url>%2F2019%2F03%2F19%2Fcommon-design-patterns%2F</url>
    <content type="text"><![CDATA[前言设计模式的概念最早来源于建筑大师 Alexander 的《建筑的永恒方法一书》，书中的观点实际上也适用于软件设计领域。Alexander 是这样描述模式的：模式是一条有三个部分组成的通用规则：它表示了一个特定环境、一类问题和一个解决方案之间的关系。每一个模式描述了一个不断重复发生的问题，以及该问题解决方案的核心设计。 软件设计模式通常被分成三类： 创建型：创建对象时，不再直接实例化对象，而是根据特定场景，由程序来确定创建对象的方式，从而保证更高的性能、更好的架构优势。创建型模式主要有简单工厂模式、工厂方法、抽象工厂模式、单例模式、生成器模式和原型模式。 结构型：用于帮助将多个对象组织成更大的结构。结构型模式主要有适配器模式、桥接模式、组合器模式、装饰器模式、门面模式、享元模式和代理模式。 行为型：用于帮助系统间各对象的通信，以及如何控制复杂系统中的流程。行为型模式主要有命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板模式和访问模式。 设计模式单例模式如何一个类始终只能创建一个实例，则这个类被称为单例类，这种模式就被称为单例模式。有时候访问系统的某些组件时只需访问其一个实例，而不需重复创建实例，如对spring 框架而言，推荐将一些公共的业务逻辑组件、DAO组件、数据源组件配置成单例的行为方式，因为这些组件无须保存任何用户状态，设为单例的行为方式，所有客户端都可以共享这些组件。 单例模式需保证类只能产生一个实例，因此需要隐藏类的构造器，同时设置一个公共静态方法用于访问该实例对象。 12345678910111213141516171819202122/*** @author Kevin Lau* @version 创建时间：Mar 19, 2019 10:07:07 PM* @Description 单例模式:1.减少重复创建实例带来的系统开销 2.便于跟踪单个实例生命周期、状态*/public class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; public static void main(String[] args) &#123; Singleton instance1 = Singleton.getInstance(); Singleton instance2 = Singleton.getInstance(); // 查看两个对象是否相等 System.out.println(instance1 == instance2); &#125;&#125; 简单工厂日常开发中，常常会遇到应用中各实例之间存在复杂的调用关系，即依赖关系，如 A 实例需要调用 B 实例，则称 A 实例依赖于 B 实例。在 A 对象需要调用 B 对象的方法时，最普通的做法是使用 new 关键字来创建 B对象，再用 B 对象来调用其方法。从语法的角度，这不会出现任何问题，但该做法的弊端在于：A 类方法内直接调用了 B 类的类名，这种方式便是硬编码耦合，当系统需要重构时，如果需要用 C 替换 B，那么就需要修改 A 方法，如果有成百上千个类都以类似 A 的方式耦合了 B，那么要修改的地方也有成百上千个，这是非常可怕的。 如果换一个角度来思考这个问题， A 不关心 B 的构造过程是怎么的，它只需要用到 B 的方法而已。考虑让 B 实现一个接口 IB，而 A 只需要 IB 接口耦合， A 不需直接通过 new 的方式来获得 B 实例，而是通过一个工厂类 IBFactory 来负责创建 B实例；A 只需通过工厂的方法即可获得B实例。如果系统重构时需要用 C 替换B，则 C 也实现 IB 接口，并且工厂原来创建 B 实例的方法改为创建 C 实例就可以了。 观看以下一个例子， 某位主人想撸猫, 他不关心猫是怎样产生的，只想在撸猫过程中听到猫叫和看到猫吃东西， 则通过动物工厂拿到了猫的实例对象，然后调用猫的行为方法，在这个过程中，猫实现了动物接口的基本行为，主人只需与猫的特殊抽象：动物接口耦合，并通过工厂返回动物接口的猫实例，就能与猫互动了。假若有一天，他觉得猫太高冷了不想撸猫想撸狗了，则同样将狗这个对象实现动物接口的基本方法，然后修改工厂方法改为生产狗就行了，不需要修改这位主人的主体行为方法。 123456789/*** @author Kevin Lau* @version 创建时间：Mar 19, 2019 10:54:33 PM* @Description 接口动物的行为*/public interface Animal &#123; void speak(); void eat();&#125; 1234567891011121314/*** @author Kevin Lau* @version 创建时间：Mar 19, 2019 10:48:34 PM* @Description 猫的行为*/public class Cat implements Animal&#123; public void speak() &#123; System.out.println("喵喵喵~~"); &#125; public void eat() &#123; System.out.println("我要吃鱼。"); &#125;&#125; 1234567891011121314/*** @author Kevin Lau* @version 创建时间：Mar 19, 2019 10:51:06 PM* @Description 狗的行为*/public class Dog implements Animal&#123; public void speak() &#123; System.out.println(&quot;旺旺旺~~&quot;); &#125; public void eat() &#123; System.out.println(&quot;我要啃骨头。&quot;); &#125;&#125; 123456789101112/*** @author Kevin Lau* @version 创建时间：Mar 19, 2019 10:55:25 PM* @Description 动物梦工厂*/public class AnimalFactory &#123; public Animal getAnimal() &#123; return new Cat(); //return new Dog(); &#125;&#125; 1234567891011121314151617181920/*** @author Kevin Lau* @version 创建时间：Mar 19, 2019 10:53:09 PM* @Description 人的行为*/public class Master &#123; public static void playWithAnimal() &#123; // 传统做法 // Cat cat = new Cat(); // Dog dog = new Dog(); AnimalFactory factory = new AnimalFactory(); Animal animal = factory.getAnimal(); animal.speak(); animal.eat(); &#125; public static void main(String[] args) &#123; playWithAnimal(); &#125; &#125; 工厂方法在简单工厂模式中，系统使用工厂类来生产实例，由该工厂类来决定生产哪个类的实例，若要返回不同实例则需修改逻辑判断，如果不想在工厂类中进行逻辑判断，可以为不同产品类提供不同的工厂，由不同的工厂类来生产对应的实例。 以上面为例子，将动物工厂抽象成接口，同时提供生产猫和生产狗的两个工厂实现类 12345678/*** @author Kevin Lau* @version 创建时间：Mar 19, 2019 10:55:25 PM* @Description 动物梦工厂*/public interface AnimalFactory &#123; Animal getAnimal();&#125; 1234567891011/*** @author Kevin Lau* @version 创建时间：Mar 20, 2019 9:27:38 PM* @Description 猫工厂*/public class CatFactory implements AnimalFactory&#123; @Override public Animal getAnimal() &#123; return new Cat(); &#125;&#125; 1234567891011/*** @author Kevin Lau* @version 创建时间：Mar 20, 2019 9:25:13 PM* @Description 狗工厂*/public class DogFactory implements AnimalFactory&#123; @Override public Animal getAnimal() &#123; return new Dog(); &#125;&#125; 123456789101112131415161718192021222324/*** @author Kevin Lau* @version 创建时间：Mar 19, 2019 10:53:09 PM* @Description 人的行为*/public class Master &#123; public static void playWithAnimal() &#123; // 撸猫 CatFactory catFactory = new CatFactory(); Animal cat = catFactory.getAnimal(); cat.speak(); cat.eat(); // 撸狗 DogFactory dogFactory = new DogFactory(); Animal dog = dogFactory.getAnimal(); dog.speak(); dog.eat(); &#125; public static void main(String[] args) &#123; playWithAnimal(); &#125;&#125; 抽象工厂从上面工厂方法的例子可看出，如果客户端需要调用多个不同的 Animal 实例时，程序必须要显式地创建不同的 AnimalFactory 实例，虽然客户端代码避免了与被调用对象的耦合，却需要与不同的工厂类进行耦合，这依然是个问题。 为了解决客户端与不同工厂类耦合的问题，考虑新增一个工厂类，但这个工厂类不是生产 Animal 实例，而是生产 AnimalFactory 实例，也就是说这个工厂类不再生产具体的被调用对象，而是生产工厂对象，这种设计模式也被称为抽象工厂模式。 123456789101112131415/*** @author Kevin Lau* @version 创建时间：Mar 20, 2019 9:51:04 PM* @Description 抽象工厂*/public class AnimalFactoryFactory &#123; public static AnimalFactory getAnimalFactory(String type) &#123; if ("cat".equalsIgnoreCase(type)) &#123; return new CatFactory(); &#125; else if ("dog".equalsIgnoreCase(type)) &#123; return new DogFactory(); &#125; return null; &#125;&#125; 代理模式代理模式是指当客户端需要调用某个对象时，客户端实际上不关心是否调用真正的对象，它只需要一个能够提供一个功能的对象即可，这样就可以使用真实对象的代理来达到使用该功能的目的。 总而言之，只要客户端不能或不想直接访问被调用对象，都可以通过设置代理对象来访问被代理对象的功能，出现这种情况的原因有很多，比如当需要创建一个系统开销比较大的对象或者被调用对象在远程主机上，又或者被调用对象需要增强功能时都可以设置代理。 观察下面一个例子，首先创建了一个图片接口，提供了一个对应的大图片实现类，其中从该实现类的构建方法可知实例化该对象时会有3秒的停顿，其实是为了模拟真实情况下大图片加载所带来的一定时间的花销。如果采用代理模式，直接实例化 BigImage，则系统会产生 3s 延迟，为了避免这种延迟，采用代理模式，新建了一个代理类，ImageProxy，同样实现了 Image 接口，内部有一个Image接口成员，用来指向被代理对象，从 show()方法可看出，当需要使用 show 功能时才会实例化被代理对象，因此系统初始化时实例化代理类不会产生额外的花销。 12345678/*** @author Kevin Lau* @version 创建时间：Mar 20, 2019 10:21:32 PM* @description 图片接口*/public interface Image &#123; void show();&#125; 123456789101112131415161718192021/*** @author Kevin Lau* @version 创建时间：Mar 20, 2019 10:22:02 PM* @Description 大图片*/public class BigImage implements Image &#123; public BigImage() &#123; try &#123; // 暂停3秒，模拟系统花销 Thread.sleep(3000); System.out.println("图片装载成功"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void show() &#123; System.out.println("绘制大图片"); &#125;&#125; 123456789101112131415161718192021/*** @author Kevin Lau* @version 创建时间：Mar 20, 2019 10:24:45 PM* @description 图片代理*/public class ImageProxy implements Image &#123; private Image image; public ImageProxy(Image image) &#123; this.image = image; &#125; @Override public void show() &#123; // 只有真正需要用到 show 方法时才会创建被代理对象 if (image == null) &#123; image = new BigImage(); &#125; image.show(); &#125;&#125; 12345678910111213/*** @author Kevin Lau* @version 创建时间：Mar 20, 2019 10:43:03 PM*/public class ProxyTest &#123; public static void main(String[] args) &#123; long start = System.currentTimeMillis(); Image image = new ImageProxy(null); System.out.println("系统得到 Image 对象的时间开销: " + (System.currentTimeMillis() - start)); // 只有真正调用show方法时才会创建被代理对象 image.show(); &#125;&#125; 上面运行输出： 123系统得到 Image 对象的时间开销:0图片装载成功绘制大图片 从结果可知，代理类其实是延迟了被代理对象的实例化，也就是延迟了系统开销，系统开销并不会减少，既然如此，使用代理类的好处是？可以从两个方面来回答该问题： 1.将被代理对象 BigImage 推迟到真正需要时才实例化可以保证前面程序的流畅性，减少 BigImage 在内存中的存活时间，从宏观上来看的确是节省了系统的内存开销。 2.在某些情况下，系统可能永远不会真正调用到 ImageProxy 的 show 方法，意味着系统无需创建 BigImage 对象，从而在一定程序性上避免了系统内1 ·· 存开销。比如在使用对象映射框架 Hibernate 时，Hibernate 的延迟加载就是采用这种这种设计模式，当 A 实体和 B 实体存在依赖关系时，Hibernate 默认启用延迟加载，当系统加载 A 实体时，A 关联的 B 实体并未被加载出来，A 关联的都是 B实体的代理对象，当 A 真正需要访问 B 时，系统才会去数据库抓取 B 实体对应的记录。可见， Hibernate 的延迟加载充分体现了代理模式的优势, 如果不使用代理模式，系统加载 A 时，同时也加载 A 关联的所有实体，这是多么大的一笔开销。 除了上面处于系统性能考虑使用到代理模式之外，还有一种场景需要用到代理模式，便是需要增强目标对象功能的时候，当目标对象的功能不满足需求时，可以通过代理对象为被代理对象增强功能。借助 Java 提供的 Proxy 和 Invocationhandler，可以实现在运行时生成动态代理的对象，该动态代理对象就可以充当目标对象使用，同时也可增强目标对象的功能。 JDK 只能创建指定接口的动态代理，因此首先创建一个接口： 12345678/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 12:11:59 AM*/public interface Man &#123; void desc(); void run();&#125; 创建 Gunman 类实现 Man 接口 123456789101112131415/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 12:12:48 AM*/public class GunMan implements Man&#123; @Override public void desc() &#123; System.out.println("我是男人"); &#125; @Override public void run() &#123; System.out.println("我奔跑迅速"); &#125;&#125; 假设客户端需要增强 Gunman 类的功能，比如添加事务控制，在目标方法执行之前开始事务，在目标方法执行之后结束事务。为了实现该功能，可以为目标对象创建一个代理对象，该代理对像实现了目标对象的接口，拥有目标对象的方法，并且增加了事务控制功能。 首先创建一个事务控制类，包括两个方法分别代表开始和结束事务。 123456789101112/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 12:15:35 AM*/public class TxUtil &#123; public void beginTx() &#123; System.out.println("=== 模拟事务开始 ==="); &#125; public void endTx() &#123; System.out.println("=== 模拟事务结束 ==="); &#125;&#125; 创建 InvocationHandler 接口的实现类，该接口的方法 invoke 方法将会作为代理对象的方法实现。通过这种方式，使得代理对象的方法既回调了被代理对象的方法，也为被代理对象的方法增加了事务功能。1234567891011121314151617181920212223242526/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 12:17:04 AM* @Description 动态处理器*/public class MyInvokationHandler implements InvocationHandler&#123; // 被代理对象 private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; // 当执行动态代理对象方法时，会被替换成执行以下方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; TxUtil tx = new TxUtil(); // 模拟事务开始 tx.beginTx(); // 以 target 作为主调来执行 method 方法 Object result = method.invoke(target, args); // 模拟事务结束 tx.endTx(); return result; &#125;&#125; 下面的动态代理工厂类将为指定的被代理对象生成动态代理实例，这个动态代理对象与被代理对象实现了相同的接口，当程序调用动态代理对象的公共方法时，实际上将会变成执行 MyInvokationHandler 的 invoke() 方法。123456789101112/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 12:24:16 AM* @Description 动态代理工厂*/public class MyProxyFactory &#123; public static Object getProxy(Object target) throws Exception&#123; MyInvokationHandler handler = new MyInvokationHandler(); handler.setTarget(target); return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler); &#125;&#125; 测试类12345678910111213/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 12:28:21 AM*/public class Test &#123; public static void main(String[] args) throws Exception &#123; Man target = new GunMan(); // 指定 target 来创建动态代理对象 Man manProxy = (Man)MyProxyFactory.getProxy(target); manProxy.desc(); manProxy.run(); &#125;&#125; 执行main方法，输出： 123456=== 模拟事务开始 ===我是男人=== 模拟事务结束 ====== 模拟事务开始 ===我奔跑迅速=== 模拟事务结束 === 策略模式策略模式用来封装系列算法，这些算法通常被封装在一个被称为 Context 的类中，客户端程序可以自由选择其中一种算法，或者让 Context 为客户端选择一个最佳的算法，使用策略模式的目的是为了支持算法的自由切换。 考虑一种场景，比如网上书店会偶尔进行优惠购书的促销活动，那么网站需要考虑各种打折促销的活动。为了实现这些需求，程序传统做法使用如下方式来实现： 1234567891011121314151617181920212223242526272829303132333435363738/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 11:05:33 PM*/public class Discount &#123; private final static int VIP_DISCOUNT = 1; private final static int OLD_DISCOUNT = 2; private int discountType; public int getDiscountType() &#123; return discountType; &#125; public void setDiscountType(int disCountType) &#123; this.discountType = disCountType; &#125; public double discount(double price) &#123; // 针对不同情况采取不同的算法 switch (getDiscountType()) &#123; case VIP_DISCOUNT: return vipDiscount(price); case OLD_DISCOUNT: return oldDiscount(price); default: break; &#125; return 1.0; &#125; public double vipDiscount(double price) &#123; return price * 0.5; &#125; public double oldDiscount(double price) &#123; return price * 0.7; &#125;&#125; 这段程序没有什么问题，但如果继续添加不同种类的折扣，则要至少要修改程序3个地方，首先要添加一个表示折扣种类的常量，然后在 switch 中新增一个case，最后还要添加一个计算新折扣的方法。根据 Java 设计对扩展开放对修改关闭的原则，这段程序显然不符合我们的要求。这种情况下，可以考虑使用策略模式来实现打折促销的功能。 创建一个折扣策略接口12345678/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 11:07:35 PM*/public interface DiscountStrategy &#123; // 定义一个用于计算打折价的方法 double getDiscount(double originPrice);&#125; 创建两个策略类1234567891011/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 11:09:47 PM*/public class OldDiscount implements DiscountStrategy&#123; @Override public double getDiscount(double originPrice) &#123; System.out.println("使用旧书折扣..."); return originPrice * 0.7; &#125;&#125; 1234567891011/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 11:08:18 PM*/public class VipDiscount implements DiscountStrategy&#123; @Override public double getDiscount(double originPrice) &#123; System.out.println("使用 VIP 折扣"); return originPrice * 0.5; &#125;&#125; DiscountContext 类，为用户推荐折扣策略，也允许用户自行选择折扣策略。该 Context 类扮演了决策者的角色，它决定调用那个折扣策略来处理图书打折。 1234567891011121314151617181920212223242526/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 11:10:51 PM*/public class DiscountContext &#123; // 组合一个 DiscountStrategy 对象 private DiscountStrategy strategy; // 构造器，传入一个 DiscountStrategy 对象 public DiscountContext(DiscountStrategy strategy) &#123; this.strategy = strategy; &#125; // 根据实际所使用的 DiscountStrategy 对象得到折扣价 public double getDiscountPrice(double price) &#123; // 如果 strategy 为 null，则自动选择 oldDiscount 方法 if (strategy == null) &#123; strategy = new OldDiscount(); &#125; return this.strategy.getDiscount(price); &#125; // 提供切换算法的方法 public void changeDiscount(DiscountStrategy strategy) &#123; this.strategy = strategy; &#125;&#125; 测试类1234567891011121314/*** @author Kevin Lau* @version 创建时间：Mar 21, 2019 11:16:17 PM*/public class StrategyTest &#123; public static void main(String[] args) &#123; DiscountContext dContext = new DiscountContext(null); double price1 = 100; System.out.println("100 元书默认打折后的价格是：" + dContext.getDiscountPrice(price1)); dContext.changeDiscount(new VipDiscount()); double price2 = 100; System.out.println("100 元书VIP打折后的价格是：" + dContext.getDiscountPrice(price2)); &#125;&#125; 重新考虑前面的需求，当业务需要新增一种打折类型，系统只需要新定义一个 DiscountStrategy实现类，实现接口的 getDiscount() 方法，用于实现新的折扣算法。当客户端需要改变折扣策略时，使用 DiscountContext 的 changeDiscount() 方法切换为新定义的折扣策略即可。 观察者模式观察者模式是指在对象之间定义了一对多的依赖关系，当一个对象的状态发生改变时，依赖它的对象(观察者对象)就能收到系统的通知，从而使得观察者对象能够自动更新。 就相当于订阅者模式，发布者发布消息，订阅者订阅了发布者后就能收到通知或提示，比如你在社交平台上关注了某个人，当他/她更新了动态后，你就能收到系统通知。 观察下面例子来了解观察者模式： 首先创建一个观察者接口12345678/*** @author Kevin Lau* @version 创建时间：Mar 26, 2019 10:02:21 PM* @Description 观察者接口，每个观察者都要实现该接口*/public interface Observer &#123; void update(Observable observer, Object arg);&#125; 被观察者抽象基类，被观察者需要继承该抽象基类，类中提供了注册、删除观察者和通知观察者的方法。12345678910111213141516171819202122232425262728/*** @author Kevin Lau* @version 创建时间：Mar 26, 2019 10:07:00 PM* @Description 被观察者抽象基类*/public abstract class Observable &#123; // List 集合用来保存该对象上所有绑定的事件监听器 List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); // 从该主题上注册观察者/订阅者 public void registObserver(Observer observer) &#123; observers.add(observer); &#125; // 从该主题中删除观察者/订阅者 public void removeObserver(Observer observer) &#123; observers.remove(observer); &#125; // 通知该主题上订阅的所有观察者 public void notifyObservers(Object value) &#123; for(Observer observer : observers) &#123; // 显示调用每个观察者的 update 方法 observer.update(this, value); &#125; &#125; &#125; 下面创建了一个具体的被观察类：产品类，有两个属性名称和价格，当其属性改变时，调用抽象基类的通知方法。12345678910111213141516171819202122232425262728293031323334/*** @author Kevin Lau* @version 创建时间：Mar 26, 2019 10:16:10 PM* @Description 被观察者，产品*/public class Product extends Observable&#123; private String name; private double price; public Product() &#123;&#125; public Product(String name, double price) &#123; this.name = name; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; notifyObservers(name); &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; notifyObservers(price); &#125;&#125; 具体的观察者，名称观察者，当产品名称发生改变，将收到通知并打印名称消息。1234567891011121314/*** @author Kevin Lau* @version 创建时间：Mar 26, 2019 10:21:42 PM* @Description 名称观察者*/public class NameObserver implements Observer&#123; @Override public void update(Observable observer, Object arg) &#123; if (arg instanceof String) &#123; String name = (String)arg; System.out.println("被观察者"+ observer + "产品名称更改为：" + name); &#125; &#125;&#125; 具体的观察者，价格观察者，具体的观察者，当产品价格发生改变，将收到通知并打印价格消息。12345678910111213/*** @author Kevin Lau* @version 创建时间：Mar 26, 2019 10:25:41 PM* @Description 价格观察者*/public class PriceObserver implements Observer&#123; @Override public void update(Observable observer, Object arg) &#123; if (arg instanceof Double) &#123; System.out.println("被观察者"+ observer + "产品价格改变为：" + arg); &#125; &#125;&#125; 测试类 1234567891011121314151617181920/*** @author Kevin Lau* @version 创建时间：Mar 26, 2019 10:30:25 PM* @Description 测试类*/public class Test &#123; public static void main(String[] args) &#123; // 被观察者 Product product = new Product("手机", 1999); // 观察者 NameObserver nameObserver = new NameObserver(); PriceObserver priceObserver = new PriceObserver(); // 向被观察者注册两个观察者对象 product.registObserver(nameObserver); product.registObserver(priceObserver); product.setName("电脑"); product.setPrice(4999); &#125;&#125; 参考链接： 轻量级Java EE企业应用实战 罗汉果]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova开发篇]]></title>
    <url>%2F2019%2F01%2F29%2Fcordova-dev-learn%2F</url>
    <content type="text"><![CDATA[Android 平台支持的Android API级别和过去几个cordova-android版本的Android版本： cordova-android 版本 支持的 API 级别 实际安卓版本 7.X.X 19 - 27 4.4 - 8.1 6.X.X 16 - 26 4.1 - 8.0.0 5.X.X 14 - 23 4.0 - 6.0.1 4.1.X 14 - 22 4.0 - 5.1 4.0.X 10 - 22 2.3.3 - 5.1 3.7.X 10 - 21 2.3.3 - 5.0.2 需要注意的是，此处列出的版本适用于Cordova的Android软件包，cordova-android，而不适用于Cordova CLI。 要确定Cordova项目中安装的Cordova Android软件包的版本，请在包含项目的目录中运行命令cordova platform ls。 通常情况下，当某个Android版本在谷歌的发布平台上的支持率低于5%时，Cordova 就不再支持该Android版本。 需求安装 Java Development Kit(JDK) 下载安装 Java 开发工具包 JDK8。 Gradle 从Cordova-Android 6.4.0 起, 要构建 Android应用就必须安装Gradle。 Android SDK 安装 Android Studio, 具体安装说明请查看 Android 开发网站。 添加 SDK 包 在安装完 Android SDK后，您还必须安装您希望开发的任何API级别的包,建议您安装您的cordova-android 所支持的最高 API 版本。 具体：打开 Android SDK 管理器，并且确保安装以下内容： 您要开发的 Android SDK 版本 Android SDK 管理工具，版本在 19.1.0 以上。 Android支持库(可在“Extras”下找到) 环境变量设置 将 $JAVA_HOME 环境变量设置为JDK安装的位置 将 $ANDROID_HOME 环境变量设置为 Android SDK 安装的位置 同时也将 Android SDK 安装目录中的 tools， tools/bin 和 platfrom-tools 添加到环境变量。 如果您是 OS X 或 Linux 系统，可以编辑 ~/.bash_profile 文件进行环境变量设置，如： 1export ANDROID_HOME=/Development/android-sdk/ 更新系统 PATH： 1export PATH=$&#123;PATH&#125;:/Development/android-sdk/platform-tools:/Development/android-sdk/tools 使添加的环境变量生效： 1$ source ~/.bash_profile 如果您是windows 系统，网上有很多设置设置安卓环境变量的教程，这里不再说明。 项目配置模拟器配置：如果您希望你的Cordova App 运行在安卓模拟器上，您首先需要创建一个安卓虚拟机(AVD), 通常可以在 Android Studio 上快速创建和配置。AVD 创建完后，便可以通过 Cordova 命令运行App在模拟器上： 1$ cordova run --emulator Gradle 配置：对于cordova-android@4.0.0 以上，Cordova的安卓项目是使用Gradle构建的。 有关使用Ant构建的说明，请参阅文档的旧版本，注意，从Android SDK Tools 25.3.0开始，就已经不推荐使用Ant版本。 Gradle属性配置： 可以通过设置 Cordova 公开的一些属性来配置 Gradle，以下是关于这些属性的说明： 属性 说明 cdvBuildMultipleApks 配置这个属性，将生成多个 APK 文件，分别对应支持 X86、ARM 等平台，如果您的项目使用大型本地库，这个很重要，可以大大增加生成的APK 大小。如果不设置，则会生成一个可在多平台架构上使用的APK。 cdvVersionCode 会覆盖 AndroidManifest.xml 中的版本号 cdvReleaseSigningPropertiesFile 配置发行应用的签名文件，默认：release-signing.properties cdvDebugSigningPropertiesFile 构建调试应用的签名文件，默认：debug-signing.properties, 在需要与其他开发人员共享签名密钥时非常有用 cdvMinSdkVersion 覆盖 AndroidManifest.xml 中的 minSdkVersion, 在根据 SDK 版本创建多个 APK时有用。 cdvBuildToolsVersion 覆盖自动检测到的 android.buildToolsVersion 值 cdvCompileSdkVersion 覆盖自动检测到的 android.compileSdkVersion 值 你可以通过以下 4 种方式来设置这些属性： 通过设置环境变量： 12$ export ORG_GRADLE_PROJECT_cdvMinSdkVersion=20$ cordova build android 在 Cordova build 或 run 命令中使用 –gradleArg 参数： 1$ cordova run android -- --gradleArg=-PcdvMinSdkVersion=20 在 /platforms/android 目录下创建一个文件：gradle.properties，输入类似以下内容： 12# In &lt;your-project&gt;/platforms/android/gradle.propertiescdvMinSdkVersion=20 使用 build-extras.gradle 文件对 build.gradle 进行扩展，类似如下所示设置属性： 12// In &lt;your-project&gt;/platforms/android/build-extras.gradleext.cdvMinSdkVersion = 20 后面两种方式都是通过在您的安卓平台目录下添加一个额外的文件来进行属性配置，通常，不建议您编辑此文件夹的内容，因为这些更改很容易丢失或覆盖。 相反，应使用before_build hook 将这两个文件从另一个位置复制到该文件夹中作为构建命令的一部分。 扩展 build.gradle 文件如果您需要自定义 build.gradle 文件，您应该创建一个名为build-extras.gradle的兄弟文件。此文件必须放在android平台目录（ / platforms / android）中，因此建议您通过附加到before_build挂钩的脚本将其复制。 一个例子如下： 12345678// Example build-extras.gradle// This file is included at the beginning of `build.gradle`ext.cdvDebugSigningPropertiesFile = '../../android-debug-keys.properties'// When set, this function allows code to run at the end of `build.gradle`ext.postBuildExtras = &#123; android.buildTypes.debug.applicationIdSuffix = '.debug'&#125; 请注意，插件还可以通过以下方式包含build-extras.gradle文件： 1&lt;framework src="some.gradle" custom="true" type="gradleReference" /&gt; 设置版本号要更改应用程序生成的apk的版本代码，请在应用程序的config.xml文件的widget元素中设置android-versionCode属性。 如果未设置android-versionCode，则将使用version属性确定版本代码。 例如，如果版本是MAJOR.MINOR.PATCH： 1versionCode = MAJOR * 10000 + MINOR * 100 + PATCH 如果您的应用程序已启用cdvBuildMultipleApks Gradle属性（请参阅设置Gradle属性），则应用程序的版本代码也将乘以10，以便代码的最后一位数字可用于指示apk构建的体系结构。 无论版本代码是从android-versionCode属性获取还是使用 version 生成，都会发生这种乘法。 请注意，添加到项目中的某些插件（包括cordova-plugin-crosswalk-webview）可能会自动设置此Gradle属性。 请注意：更新android-versionCode属性时，从构建的apks获取的版本号来增加是不明智的。 相反，您应该根据config.xml文件的android-versionCode属性中的值来增加。 这是因为cdvBuildMultipleApks属性导致版本号在构建的apks中乘以10，因此使用该值将导致您的下一个版本代码是原始版本号的100倍，等等。 签署应用程序使用标志要签署应用程序，您需要用到以下参数： 参数 标志 说明 Keystore –keystore 二进制文件的路径，可以容纳一组密钥 Keystore Password –storePassword 密钥库的密码 Alias –alias id指定用于签名的私钥 Password –password 指定私钥的密码 Type of the Keystore –keystoreType 默认值：基于文件扩展名自动检测 无论是pkcs12还是jks默认值：基于文件扩展名自动检测无论是pkcs12还是jks 可以使用上面的命令行参数为Cordova CLI构建或运行命令指定这些参数。 注意：您应该使用双 “-“ 表示这些是特定于平台的参数，例如： 1cordova run android --release -- --keystore=../my-release-key.keystore --storePassword=password --alias=alias_name --password=password 使用 build.json或者，您可以使用相同命令的–buildConfig参数在构建配置文件（build.json）中指定它们。 以下是构建配置文件的示例： 123456789101112131415161718&#123; "android": &#123; "debug": &#123; "keystore": "../android.keystore", "storePassword": "android", "alias": "mykey1", "password" : "password", "keystoreType": "" &#125;, "release": &#123; "keystore": "../android.keystore", "storePassword": "", "alias": "mykey2", "password" : "password", "keystoreType": "" &#125; &#125;&#125; 对于发布签名，可以排除密码，构建系统将发出询问密码的提示。 还支持在build.json中混合和匹配命令行参数和参数。 命令行参数中的值将优先。 这对于在命令行上指定密码很有用。 使用 Gradle您还可以通过包含.properties文件并使用cdvReleaseSigningPropertiesFile和cdvDebugSigningPropertiesFile Gradle属性指向它来指定签名属性（请参阅设置Gradle属性）。 该文件应如下所示： 12345storeFile=relative/path/to/keystore.p12storePassword=SECRET1storeType=pkcs12keyAlias=DebugSigningKeykeyPassword=SECRET2 storePassword和keyPassword是可选的，如果省略则会提示输入。 调试有关Android SDK随附的调试工具的详细信息，请参阅Android的开发人员文档以进行调试。 此外，Android的用于调试Web应用程序的开发人员文档提供了有关调试Webview中运行的应用程序部分的简介。 Android Studio中打开一个项目Cordova-Android 项目可以在 Android Studio中打开。 如果您希望使用Android Studio内置的Android调试/分析工具，或者您正在开发Android插件，这将非常有用。 请注意，在Android studio中打开项目时，建议您不要在IDE中编辑代码。 这将编辑项目的平台文件夹（而不是www）中的代码，并且可能会覆盖更改。您应该编辑www文件夹并通过运行cordova build复制您的更改。 希望在IDE中编辑其本机代码的插件开发人员在通过cordova插件添加将其插件添加到项目时应使用–link标志。 这将链接文件，以便对平台文件夹中的插件文件的更改反映在插件的源文件夹中（反之亦然）。 要在Android Studio中打开Cordova-Android 项目： 启动 Android Studio 选择导入一个项目 选择 Android 平台目录，(/platforms/android). 对于Gradle Sync问题，您只需回答“是”即可。 完成导入后，您应该能够直接从Android Studio构建和运行应用程序。 有关详细信息，请参阅Android Studio概述以及从Android Studio构建和运行。 以平台为中心的工作流程cordova-android包含许多脚本，允许在没有完整Cordova CLI的情况下使用该平台。 在某些情况下，此开发路径可为您提供比跨平台cordova CLI更多的开发选项。 例如，在将自定义Cordova WebView与本机组件一起部署时，需要使用shell工具。 在使用此开发路径之前，您仍必须按照上面的“要求和支持”中的说明配置Android SDK环境。 有关下面讨论的每个脚本，请参阅 Cordova CLI。 每个脚本都有一个与相应CLI命令匹配的名称。 例如，cordova-android / bin / create相当于cordova创建。 首先，从npm或Github下载cordova-android软件包。 要使用此包创建项目，请在bin文件夹中运行create script： 1$ cordova-android/bin/create 创建的项目将在其中包含一个名为cordova的文件夹，其中包含项目特定Cordova命令的脚本（例如，运行，构建等）。 此外，该项目将采用与普通Cordova项目不同的结构。 值得注意的是，/ www被移至/ assets / www。 声明周期Cordova 与 Android原生Android应用程序通常包含用户与之交互的一系列活动。 可以将活动视为构成应用程序的各个屏幕; 应用程序中的不同任务通常会有自己的活动。 每个活动都有自己的生命周期，在活动进入和离开用户设备的前台时进行维护。 相比之下，Android平台上的Cordova应用程序在嵌入在单个Android活动中的Webview中执行。 此活动的生命周期通过触发的文档事件向您的应用程序公开。 这些事件不能保证与Android的生命周期一致，但它们可以提供保存和恢复状态的指南。 这些事件大致映射到Android回调，如下所示： Cordova 事件 对应的 Andrid 事件 说明 deviceready onCreate() 应用程序正在启动（不是从后台） pause onPause() 应用程序进入后台运行 resume onResume() 应用程序返回到前台 大多数其他Cordova平台都有类似的生命周期概念，并且当用户的设备上发生类似的操作时，应触发这些相同的事件。 然而，Android带来了一些独特的挑战，由于原生活动生命周期，这些挑战有时会出现。 为什么 Android 与众不同？在Android中，操作系统可以选择在后台终止活动，以便在设备内存不足时释放资源。 不幸的是，当您的应用程序活动被终止时，您的应用程序所在的Webview也将被销毁。 在这种情况下，您的应用程序维护的任何状态都将丢失。 当用户导航回您的应用程序时，操作系统将重新创建活动和Web视图，但不会为您的Cordova应用程序自动恢复状态。 因此，您的应用程序必须了解触发的生命周期事件并维护适当的状态，以确保应用程序中的用户上下文在离开应用程序时不会丢失。 什么时候会发生？您的应用程序在离开用户视线时很容易被操作系统破坏， 有两种主要情况可能发生。 第一个也是最明显的情况是用户按下主页按钮或切换到另一个应用程序。 但是，某些插件可以引起第二种（更微妙的）情况。 如上所述，Cordova应用程序通常仅限于包含Webview的单个活动。 但是，有些情况下插件可以启动其他活动，并暂时将Cordova活动推送到后台。 通常会启动这些其他活动，以便使用设备上安装的本机应用程序执行特定任务。 例如，Cordova相机插件会启动设备上原生安装的任何相机活动以拍摄照片。 以这种方式重新使用已安装的相机应用程序会使您的应用程序在用户尝试拍照时更像本机应用程序。 不幸的是，当本机Activity将您的应用推送到后台时，操作系统有可能会将其杀死。 为了更清楚地理解第二种情况，让我们来看一个使用相机插件的例子。 想象一下，您有一个需要用户拍摄个人资料照片的应用程序。 一切按计划进行时，应用程序中的事件流将如下所示： 用户正在与您的应用进行交互，需要拍照 相机插件启动本地相机活动 Cordova活动被推送到后台(触发暂停事件) 用户拍了一张照片 相机活动结束 Cordova活动被移到前台（恢复事件被触发） 用户返回到他们中断的应用程序 但是，如果设备内存不足，则可能会中断此事件流。 如果活动被操作系统杀死，则上述事件序列将显示如下： 用户正在使用您的应用程序并且需要拍一张照片 相机插件启动本地相机活动 操作系统破坏Cordova活动（暂停事件被触发） 用户拍了一张照片 相机活动完成 操作系统重新创建Cordova活动（deviceready 和resume 事件被触发） 用户对于他们突然回到您应用的登录屏幕的原因感到困惑 在这种情况下，操作系统在后台杀死了应用程序，并且应用程序没有将其状态维持为生命周期的一部分。 当用户返回到应用程序时，Webview被重新创建，并且应用程序似乎已从头开始重新启动（因此用户感到困惑）。 这一系列事件等同于按下主页按钮或用户切换应用程序时发生的事件。 防止上述情况出现的关键是订阅事件并将状态正确地保持为活动生命周期的一部分。 遵循生命周期在上面的示例中，触发的javascript事件(斜体显示部分)。 这些事件是您保存和恢复应用程序状态的机会。 您应该在应用程序的 bindEvents 函数中注册回调，该函数通过保存状态来响应生命周期事件。 您保存的信息以及保存方式由您自行决定，但您应确保保存足够的信息，以便用户可以在用户返回应用程序时将其恢复到原来的位置。 在上面的示例中还有一个附加因素仅适用于第二个讨论的情况（即插件启动外部活动时）。 当用户完成拍照时，不仅应用程序的状态丢失，而且用户拍摄的照片也是如此。 通常，该照片将通过在相机插件中注册的回调传送到您的应用程序。 然而，当Webview被破坏时，回调永远丢失了。 幸运的是，cordova-android 5.1.0及更高版本提供了一种在应用程序恢复时获取该插件调用结果的方法。 获取插件回调结果(cordova-android 5.1.0+)当操作系统破坏通过插件推送到后台的Cordova活动时，任何挂起的回调也会丢失。 这意味着如果您将回调传递给启动新活动的插件（例如相机插件），则在重新创建应用程序时不会触发该回调。 但是，从cordova-android 5.1.0开始，resume 事件的有效负载将包含插件请求中的任何挂起的插件结果，这些结果来自于在活动被销毁之前启动外部活动的插件请求。 resume事件的有效负载遵循以下格式： 12345678&#123; action: "resume", pendingResult: &#123; pluginServiceName: string, pluginStatus: string, result: any &#125;&#125; 该有效载荷的字段定义如下： pluginServiceName：返回结果的插件的名称（例如“Camera”）。 这可以在插件的plugin.xml文件的标记中找到 pluginStatus：插件调用的状态（见下文） result：无论插件调用的结果是什么 pendingResult字段中pluginStatus的可能值包括以下内容： “OK” - 插件调用成功 “No Result” - 插件调用结束，没有结果 “Error” - 插件调用导致一些常见错误 其他杂项错误 “找不到类” “非法访问” “实例化错误” “格式错误的网址” “IO错误” “无效的动作” “JSON错误” 请注意，由插件决定结果字段中包含的内容以及返回的pluginStatus的含义。 查看您正在使用的插件的相关API，这些字段应该包含的内容以及如何使用它们的值。 例子下面是一个简短的示例应用程序，它使用resume和pause事件来管理状态。 它使用Apache相机插件作为如何从resume事件有效负载检索插件调用结果的示例。 处理resume的event.pendingResult对象的代码部分需要cordova-android 5.1.0+ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// This state represents the state of our application and will be saved and// restored by onResume() and onPause()var appState = &#123; takingPicture: true, imageUri: ""&#125;;var APP_STORAGE_KEY = "exampleAppState";var app = &#123; initialize: function() &#123; this.bindEvents(); &#125;, bindEvents: function() &#123; // Here we register our callbacks for the lifecycle events we care about document.addEventListener('deviceready', this.onDeviceReady, false); document.addEventListener('pause', this.onPause, false); document.addEventListener('resume', this.onResume, false); &#125;, onDeviceReady: function() &#123; document.getElementById("take-picture-button").addEventListener("click", function() &#123; // Because the camera plugin method launches an external Activity, // there is a chance that our application will be killed before the // success or failure callbacks are called. See onPause() and // onResume() where we save and restore our state to handle this case appState.takingPicture = true; navigator.camera.getPicture(cameraSuccessCallback, cameraFailureCallback, &#123; sourceType: Camera.PictureSourceType.CAMERA, destinationType: Camera.DestinationType.FILE_URI, targetWidth: 250, targetHeight: 250 &#125; ); &#125;); &#125;, onPause: function() &#123; // Here, we check to see if we are in the middle of taking a picture. If // so, we want to save our state so that we can properly retrieve the // plugin result in onResume(). We also save if we have already fetched // an image URI if(appState.takingPicture || appState.imageUri) &#123; window.localStorage.setItem(APP_STORAGE_KEY, JSON.stringify(appState)); &#125; &#125;, onResume: function(event) &#123; // Here we check for stored state and restore it if necessary. In your // application, it's up to you to keep track of where any pending plugin // results are coming from (i.e. what part of your code made the call) // and what arguments you provided to the plugin if relevant var storedState = window.localStorage.getItem(APP_STORAGE_KEY); if(storedState) &#123; appState = JSON.parse(storedState); &#125; // Check to see if we need to restore an image we took if(!appState.takingPicture &amp;&amp; appState.imageUri) &#123; document.getElementById("get-picture-result").src = appState.imageUri; &#125; // Now we can check if there is a plugin result in the event object. // This requires cordova-android 5.1.0+ else if(appState.takingPicture &amp;&amp; event.pendingResult) &#123; // Figure out whether or not the plugin call was successful and call // the relevant callback. For the camera plugin, "OK" means a // successful result and all other statuses mean error if(event.pendingResult.pluginStatus === "OK") &#123; // The camera plugin places the same result in the resume object // as it passes to the success callback passed to getPicture(), // thus we can pass it to the same callback. Other plugins may // return something else. Consult the documentation for // whatever plugin you are using to learn how to interpret the // result field cameraSuccessCallback(event.pendingResult.result); &#125; else &#123; cameraFailureCallback(event.pendingResult.result); &#125; &#125; &#125;&#125;// Here are the callbacks we pass to getPicture()function cameraSuccessCallback(imageUri) &#123; appState.takingPicture = false; appState.imageUri = imageUri; document.getElementById("get-picture-result").src = imageUri;&#125;function cameraFailureCallback(error) &#123; appState.takingPicture = false; console.log(error);&#125;app.initialize(); 对应的 html： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Security-Policy" content="default-src 'self' data: gap: https://ssl.gstatic.com 'unsafe-eval'; style-src 'self' 'unsafe-inline'; media-src *"&gt; &lt;meta name="format-detection" content="telephone=no"&gt; &lt;meta name="msapplication-tap-highlight" content="no"&gt; &lt;meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width"&gt; &lt;link rel="stylesheet" type="text/css" href="css/index.css"&gt; &lt;title&gt;Cordova Android Lifecycle Example&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="app"&gt; &lt;div&gt; &lt;img id="get-picture-result" /&gt; &lt;/div&gt; &lt;Button id="take-picture-button"&gt;Take Picture&lt;/button&gt; &lt;/div&gt; &lt;script type="text/javascript" src="cordova.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/index.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 测试 Activity(活动)的生命周期Android提供了一个开发人员设置，用于测试低内存上的Activity销毁。 在设备或仿真器的“开发人员选项”菜单中启用“不要保留活动”设置，以模拟低内存情况。 您应始终在启用此设置的情况下进行一些测试，以确保您的应用程序正确维护状态。 IOS 平台要求与支持构建iOS应用程序所需的Apple®工具需在基于Intel的Mac上的OS X操作系统上运行。 Xcode®7.0（最低要求版本）需要在OS X版本10.10.4（Yosemite）或更高版本上运行，并包含iOS 9 SDK（软件开发工具包）。 要将应用程序提交到Apple App Store，需要最新版本的Apple工具。 您可以使用随iOS SDK和Xcode一起安装的iOS模拟器测试许多Cordova功能，但在提交到App Store之前，您需要一个实际的设备来完全测试应用程序的所有设备功能。 该设备必须至少安装iOS 8，从Cordova 4.0.0开始支持最低iOS版本。 支持的设备包括iPhone 4S，iPhone 5，iPhone 5C，iPhone 5S，iPhone 6，iPhone 6 Plus，iPhone 6S，iPhone 6S Plus，iPhone SE，iPad 2，iPad 3，iPad 4，iPad Air，iPad Air 2，iPad Pro ，iPad Mini，iPad Mini 2，iPad Mini 3，iPod Touch 5th gen和iPod Touch 6th或更高版本。 要求安装Xcode有两种方式可以安装 Xcode: 在App Store中下载，可通过在App Store应用程序中搜索“Xcode”获得。 在Apple 开发平台中下载，需要注册为Apple 开发人员。 安装Xcode后，需要启用多个命令行工具才能运行Cordova。 在终端执行命令： 1$ xcode-select --install 部署工具ios-deploy工具允许您从命令行在iOS设备上启动iOS应用程序。在终端执行命令： 1$ npm install -g ios-deploy 项目配置安装完上面的东西后，您现在就可以创建和构建一个 Cordova 项目了，更多细节，请参考另一篇博文《Cordova快速入门篇》。 部署应用到模拟器要在iOS模拟器中预览应用程序： 从Xcode或命令行打开工作区文件（platforms / ios / HelloWorld.xcworkspace）： 1$ open ./platforms/ios/HelloWorld.xcworkspace/ 确保在左侧面板中选择了HelloWorld项目（1）。 从工具栏的 Scheme 菜单中选择目标设备，例如（2）中突出显示的iPhone 7 Plus Simulator 按 Scheme 菜单左侧相同工具栏中的 Run 按钮（3）。 它将在模拟器中构建，部署和运行应用程序。 将打开一个单独的模拟器应用程序以显示该应用： 一次只能运行一个模拟器，因此如果要在不同的模拟器中测试应用程序，则需要退出模拟器应用程序并在Xcode中运行不同的目标。 Xcode捆绑了最新版iPhone和iPad的模拟器。 可以从Xcode→首选项…→组件 面板中获得旧版本。 部署应用到设备有关部署到设备的各种要求的详细信息，请参阅Apple的 App 部署流程 。 简而言之，在部署之前需要执行以下操作： 在 ios 配置面板 中创建配置文件。 您可以使用 Apple 的 开发配置助手 来创建和安装 Xcode 所需的配置文件和证书。 验证构建设置中代码签名部分中的代码签名标识设置是否设置为您的配置文件名称。 部署应用到设备： 使用 USB 接口将您的设备连接到 Mac。 在 Xcode 的左侧面板的项目列表中选择您要运行的项目 在 Xcode 的 Scheme 菜单左侧的下拉列表中选择您的设备。 按下 Run 按钮，将会执行构建，部署并运行应用程序到您的设备上。 App 签名首先，请查看 Apple 开发人员网站的 代码签名支持 和 应用部署流程 使用标识符要对 App 进行签名，您需要了解以下参数： 参数名 标识符 说明 代码签名身份 –codeSignIdentity2 用于签名的代码签名身份。 它可以使用Xcode创建并添加到您的钥匙串中。 从Xcode 8开始，您应该使用–codeSignIdentity =“iPhone Developer”进行调试和发布。 开发团队 –developmentTeam 用于代码签名的开发团队（团队ID）。 您可以使用此设置和简化的代码签名身份（即只是“iPhone开发人员”）来签署您的应用程序，无需提供配置文件。 打包类型 –packageType 这会决定 Xcode 构建什么类型的 App。 有效选项包括开发（默认），企业，ad-hoc和应用商店。 配置文件 –provisioningProfile （可选）用于手动签名的配置文件的GUID。 它会在 Mac 上复制：〜/ Library / MobileDevice / Provisioning \ Profiles /。 在文本编辑器中打开它，如果使用手动签名，您可以找到需要在此处指定的GUID。 代码签名资源规则 –codesignResourceRules (可选)用来配置哪些文件会作为代码签名的捆绑，查看 OS X 代码签名 了解更多信息。 自动配置 –automaticProvisioning （可选）启用以允许Xcode自动管理配置文件。 有效选项为false（默认值）和true。 使用 build.json或者，您可以使用相同命令的–buildConfig参数在构建配置文件（build.json）中指定它们。 以下是构建配置文件的示例： 对于自动签名，配置配置文件由Xcode自动管理（推荐）： 1234567891011121314151617181920212223242526&#123; "ios": &#123; "debug": &#123; "codeSignIdentity": "iPhone Developer", "developmentTeam": "FG35JLLMXX4A", "packageType": "development", "automaticProvisioning": true, "buildFlag": [ "EMBEDDED_CONTENT_CONTAINS_SWIFT = YES", "ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=NO", "LD_RUNPATH_SEARCH_PATHS = \"@executable_path/Frameworks\"" ] &#125;, "release": &#123; "codeSignIdentity": "iPhone Developer", "developmentTeam": "FG35JLLMXX4A", "packageType": "app-store", "automaticProvisioning": true, "buildFlag": [ "EMBEDDED_CONTENT_CONTAINS_SWIFT = YES", "ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=NO", "LD_RUNPATH_SEARCH_PATHS = \"@executable_path/Frameworks\"" ] &#125; &#125;&#125; 对于手动签名，要根据 UUID 指定配置文件： 12345678910111213141516&#123; "ios": &#123; "debug": &#123; "codeSignIdentity": "iPhone Development", "provisioningProfile": "926c2bd6-8de9-4c2f-8407-1016d2d12954", "developmentTeam": "FG35JLLMXX4A", "packageType": "development" &#125;, "release": &#123; "codeSignIdentity": "iPhone Distribution", "provisioningProfile": "70f699ad-faf1-4adE-8fea-9d84738fb306", "developmentTeam": "FG35JLLMXX4A", "packageType": "app-store" &#125; &#125;&#125; Xcode 构建标志符如果您有自定义情况需要将其他构建标志传递给Xcode - 您将使用一个或多个 –buildFlag 选项将这些标志传递给 xcodebuild。 如果您使用 xcodebuild 内置标志，它将显示警告。 您还可以在上面的build.json中指定buildFlag选项（buildFlag键的值是字符串或字符串数组）。 12cordova build --device --buildFlag="MYSETTING=myvalue" --buildFlag="MY_OTHER_SETTING=othervalue"cordova run --device --buildFlag="DEVELOPMENT_TEAM=FG35JLLMXX4A" --buildFlag="-scheme TestSchemeFlag" 调试有关Xcode附带的调试工具的详细信息，请查看这篇Apple 开发调试部分。 用于iOS项目的Cordova可以在Xcode中打开。如果您希望使用内置调试/分析工具的Xcode，或者您正在开发iOS插件，这将非常有用。请注意，在Xcode中打开项目时，建议您不要在IDE中编辑代码。这将编辑项目的平台文件夹（而不是www）中的代码，并且可能会覆盖更改。而是编辑www文件夹并通过运行cordova build复制您的更改。 希望在IDE中编辑其原生代码的插件开发人员在通过cordova插件添加将其插件添加到项目时应使用–link标志。这将链接文件，以便对平台文件夹中的插件文件的更改反映在插件的源文件夹中（反之亦然）。 将ios平台添加到项目并使用cordova构建后，您可以在Xcode中打开它。双击打开$ {PROJECT_NAME} / platforms / ios / $ {PROJECT_NAME} .xcworkspace文件或从终端打开Xcode： 1$ open -a Xcode platforms/ios 界面如下所示： 更新有关升级cordova-ios版本的说明，请参阅此文章。]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cordova快速入门]]></title>
    <url>%2F2019%2F01%2F22%2Fcordova-quick-learn%2F</url>
    <content type="text"><![CDATA[背景介绍数说移动端的几种开发模式 Native App: 采用原生代码进行，优点就是体验好，缺点是需要为不同的系统平台独立开发一套应用，开发成本较高。 Web app: 一般是指 SAP(SinglePageApplication) 模式开发出的网站，体验较差。 React Native App: 是 Facebook 开源的一套App开发解决方案，让你只使用 JavaScript 也能够编写原生移动应用，它在设计原理上和 React 一致，通过声明式的组件机制来搭建丰富多彩的用户界面，能够实现大部分的跨平台，体验较好。 Hybrid App: 混合开发模式，由Native 通过 JSBridge(一种)等方法提供统一的API，然后用前端语言(HTML、JS、CSS) 来写实际的界面和逻辑，再调用API，最终应用的页面是在 webview中示，从而达到跨平台效果，常见的是用Phonegap或Cordova中间件组合其他移动UI框架进行开发。 值得注意的是，RN App 和 Hybrid App 还是有本质区别的，RN App 是用JavaScript告诉原生语言做什么，所以最终在平台上运行的都是原生语言，包括UI等，也是原生的组件，而 Hybrid App中显示的大多是 webview，webview 里套常见的移动UI框架。Hybird App的原理图如下W： Cordova的前世今生Cordova前身是 Phonegap，最先由 Nitobi 软件公司在2008年推出，旨在弥补 web 和 ios 之间的不足，使得 web 和 iphone SDK 之间的交互更容易，后来陆续加入了更多的平台。 2011年，Adobe公司收购 Nitobi 后，将phonegap 项目的核心代码捐赠给了 Apache软件基金会(ASF), 使其保持透明和持续的发展，Apchae将其命名为 Cordova，而Adobe PhoneGap则发展出了一些服务型工具，如 Phonegap destop App、 Phonegap developer App、Phonegap build、Phonegap CLI等。 很多人可能会问：那 Cordova 和 Phonegap 的区别到底是什么，其实Cordova相当于驱动 Phonegap 的核心引擎，就好比如 WebKit 是现在大多数浏览器的引擎一样，因此 Adobe PhoneGap可理解为是Apache Cordova 的应用发行版。 Cordova的架构原理图如下，可知 Cordova 是混合App开发的一个中间件。 Cordova安装安装 Cordova 前，需要准备两样东西。 下载安装 Node.js，这样就可以使用 Node.js 的 npm 软件管理包。 安装 Git，因为当涉及到一些 git 仓库时会使用 git 来下载相关的资源。 Mac Os 或 Linux平台： 1sudo npm install -g cordova Windows： 1C:\&gt;npm install -g cordova -g 参数是指告诉 npm 要全局安装 Cordova，不然会被安装在当前目录的子目录 node_modules 下。 Cordova使用创建一个 App 项目1cordova create hello[Required] com.example.hello[Optional] HelloWorld[Optional] hello 是指项目文件夹名，com.example.hello 是应用程序的 ID 名，可在 config.xml 中更改。 HelloWorld，是 App 的名称，也可在 config.xml 中更改这样就会创建最基本的App目录结构，默认会生成基于的web的应用主页，即为项目目录下的 www/index.html 目录结构Cordova 默认创建的 App 目录如下： 1234567891011121314myapp/|-- config.xml|-- hooks/|-- merges/| | |-- android/| | |-- windows/| | |-- ios/|-- www/|-- platforms/| |-- android/| |-- windows/| |-- ios/|-- plugins/ |--cordova-plugin-camera/ config.xml: 在这你可以自定义 App 项目的信息 www/: 包括项目的web代码，如 html, css 和 js 文件，你将在这开发你 App 的主要代码，另外在 plaform 目录下的ios 目录或 android 目录下，也会有一个 www 目录，是基于 project/www 目录编译覆盖的。 platform/: 包括你添加的平台的源码和脚本，注意一般不要该目录下的代码，否则可能造成在相关平台运行不了。 plugins/: 插件目录，所有添加的插件都会被解压并复制到该目录下。 hooks/：可以包含用于自定义 Cordova-CLI 命令的脚本， 您添加到这些目录的任何脚本都将在与目录名对应的命令之前和之后执行。 用于集成您自己的构建系统或与版本控制系统。 merges/: 包含一些与特定平台相关联的 web 资源(HTML, CSS 和 JavaScript 文件),放在merges /下的文件将覆盖相关平台的www /文件夹中的匹配文件。 一个简单的例子，假设一个项目结构： 1234567merges/|-- ios/| -- app.js|-- android/| -- android.jswww/-- app.js 在构建Android和iOS项目之后，Android应用程序将同时包含app.js和android.js，而iOS应用程序则只包含app.js，它是将 merges/ios/app.js，覆盖位于www/内的通用的app.js。 添加平台首先进入项目目录: 1$ cd hello 添加开发平台，会在 config.xml 和 package.json 中有记录: 12$ cordova platform add ios$ cordova platform add android 执行上面两条命令后会在 platform 目录下生成 ios 和 android 两个子目录，用来存放编译后的代码和一些app的内容。 查看项目已添加的平台： 1$ cordova platform ls 当在 www 目录下开发完毕后，用以下命令构建项目到各个平台： 构建前准备要构建和运行应用程序，您需要为您想要开发的每个平台安装对应的SDK。 或者，如果您使用浏览器进行开发，则可以使用不需要任何平台SDK的浏览器平台。 查看您是否满足必须条件： 1234567891011$ cordova requirementsRequirements check results for android:Java JDK: installed .Android SDK: installedAndroid target: installed android-19,android-21,android-22,android-23,Google Inc.:Google APIs:19,Google Inc.:Google APIs (x86 System Image):19,Google Inc.:Google APIs:23Gradle: installedRequirements check results for ios:Apple OS X: not installedCordova tooling for iOS requires Apple OS XError: Some of requirements check failed 应用构建与运行构建应用123456cordova build [&lt;platform&gt; [...]] [--debug|--release] [--device|--emulator] [--buildConfig=&lt;configfile&gt;] [--browserify] [-- &lt;platformOpts&gt;] 参数 说明 […] 要构建的平台名，没指定则为所有平台进行编译构建 –debug 构建调试模式 –release 构建发布模式 –device 构建到设备 –emulator 构建到模拟器 –buildConfig= 使用特定的配置文件来编译构建，如指定签名等。 –browserity 在构建时编译JS插件而不是运行时 提供特定的选项 运行应用1234567cordova run [&lt;platform&gt; [...]] [--list | --debug | --release] [--noprepare] [--nobuild] [--device|--emulator|--target=&lt;targetName&gt;] [--buildConfig=&lt;configfile&gt;] [--browserify] [-- &lt;platformOpts&gt;] 参数 说明 […] 要运行的平台名，没指定则所有平台都运行 –list 列出可用的运行目标，包括模拟器和设备，除非特定指定 –debug 默认选型，运行调试模式 –release 运行发布模式 –noprepare 跳过准备阶段，适用于Cordova v6.2及其之后版本。 –nobuild 跳过重新构建阶段 –device 在设备上运行 –emulator 在模拟器上运行 –target 指定运行目标 –buildConfig= 使用特定的配置文件来编译构建，如指定签名等。 –browserity 在构建时编译JS插件而不是在运行时 提供特定的选项 添加插件可以在 Cordova插件资源 页面中查询需要的插件，也可以使用命令行搜索相关插件： 1$ cordova plugin search camera 添加某个插件： 1234$ cordova plugin add cordova-plugin-cameraFetching plugin "cordova-plugin-camera@~2.1.0" via npmInstalling "cordova-plugin-camera" for androidInstalling "cordova-plugin-camera" for ios 插件也可以通过目录或 Git 仓库的形式添加 注意：（CLI为每个平台添加适当的插件代码。 如果您希望使用概述中讨论的低级shell工具或平台SDK进行开发，则需要运行Plugman实用程序以为每个平台单独添加插件。 （有关更多信息，请参阅使用Plugman管理插件。） 查看已安装的插件 123$ cordova plugin lscordova-plugin-camera 2.1.0 "Camera"cordova-plugin-whitelist 1.2.1 "Whitelist" 使用合并功能虽然Cordova允许您能够轻松地为许多不同平台部署应用程序，但实际上您时常需要添加一些自定义项。在这种情况下，您当然不希望修改不同平台下的www目录中的源文件，因为它们经常被顶级www目录的资源替换。 因此，Cordova 在顶级目录下提供了一个位置(merge目录)可以指定在哪个平台部署资源。merge目录中的平台子目录都对应着 www源码目录机构，允许您根据需要覆盖或添加文件。例如，你可能会使用合并功能为 Android 设备设置默认的字体大小： 在 www/index.html 文件中，添加一条指向额外的CSS样式文件的链接：overrides.css 1&lt;link rel="stylesheet" type="text/css" href="css/overrides.css" /&gt; （可选）创建一个空的www / css / overrides.css文件，该文件适用于所有非Android版本，防止丢失文件错误。 在merges / android中创建一个css子目录，然后添加一个相应的overrides.css文件。 指定覆盖www / css / index.css中指定的12磅默认字体大小的CSS，例如： 1body &#123; font-size:14px; &#125; 当你重新构建项目后，只有 android 平台会应用自定义字体大小的样式，而其他平台保持不变。 更新 Cordova 和您的项目升级 Cordova 版本: 1$ sudo npm update -g cordova 安装指定的 Cordova 版本： 1$ sudo npm install -g cordova@3.1.0-0.2.0 查看 Cordova 版本： 1cordova -v 查看最新 Cordova 最新版本相关信息： 1$ npm info cordova version 更新指定的平台： 123$ cordova platform update android --save$ cordova platform update ios --save...etc.]]></content>
      <categories>
        <category>mobile</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PR视频字幕批量生成程序(用讯飞听见识别音频)]]></title>
    <url>%2F2017%2F11%2F23%2Fauto-caption-procedure%2F</url>
    <content type="text"><![CDATA[用过视频剪辑软件的小伙伴们可能都会为添加视频字幕所烦恼，尤其是当一个视频包含了大量语音而且只有你一个人在配字幕的时候,那就变得很蛋疼；尽管到最后你完成了这么庞大的工作量，但是你都会一度怀疑自己的人生。我曾经为一个十来分钟的视频配字幕都配到我想吐。 然后我最近看B站发现一个挺有意思的事情,就是利用讯飞语音识别服务可以识别语音并且自动生成文字，这就省掉了不少人力去听的功夫。众所周知科大讯飞的语音识别功能是蛮强的，看过老罗手机发布会视频的就能知道。知道了这个功能后，我就想到要做一个PR字幕自动生成工具,下面将讲解我是怎么一步步实现的。 首先打开讯飞听见，遗憾的是，讯飞的这个语音识别功能是要收费的，看下价格，一种是机器快转（19.8元/小时），另一种是人机精转（80元/小时），看到这里，你是否心想：妖，都要收费的，我一个农村来的怎么负担得起。别急，我也是这样想的，继续往下看。点击上图的立即下单 进入到这个页面，我们可以发现讯飞提供了一个体验的功能，就是你可以上传一段录音来体验一下他们家的这个语音识别功能，当然它是有限制的，你最多可以同时上传50条语音，每条语音不超过500M且不超过1分钟时长。所以说，这个功能对后期才配音的人员就比较友好。当然找个工具分割一下语音也是可以的，有空我再看看能不能写段代码实现语音分割。这里我上传了两条语音来试一下 从上图可以看到它识别的准确度还是蛮高的。但如果你想要复制识别出来的文本是不行的，它已经做了限制了复制的功能。这里写了个js插件，可以一次性获取识别出的文本。 在浏览器添加插件后刷新页面 ,可以发现红色箭头处多了个按钮，点击“获取数据”按钮就可以获得文本并显示在左边箭头所指的文本框里。右下角可以自由拉大缩小文本框 全选复制上图箭头所指文本框的内容，然后新建一个txt文件或者json文件，用记事本打开粘贴到里面,然后点击菜单文件的另存为,将编码ANSI改为UTF-8,保存。注意一定要更改编码，不然后面生成的字幕文件会出现乱码。 字幕文本保存好后，接下来就要生成一个字幕模板，这里使用的Premiere CC pro 2017软件。打开PR,先根据自己的喜好制作一个字幕样式当作字幕模板。接着选中字幕模板-&gt;文件-&gt;导出-&gt;标题,就可以生成一个字幕模板 本来想分析一下整个序列的，但是不知什么原因PR导出Fianl cut pro xml总是提示有转换有问题，只好作罢。如果可以获得正确的序列的xml,就可以增改里面的代码，按时间线调整素材的顺序，再导入PR就可以自动排序好视频音频字幕的顺序 。(理论上是这样，但在我看到整个序列的xml之后，我有点怀疑我的想法，因为我感觉我在看天书。) 这里我右击打开字幕文件，找到存放字幕文本的标签TRString,这样更改里面的文本就相当于换了一个字幕文件？如果你这样做PR是不能正确识别的。还有个地方需要注意的就是更改TRString下文本的同时也要注意这个文本的长度是多少，因为CharacterAttributes这个标签下的属RunCount就是记录文本字符的长度的。但就找到并了解它们就花了我大半天，晕~~。知道了这两个标签的作用后，就可以通过程序来修改它了。 OK,一切准备就绪，就是准备好了json格式的文本和字幕模板后，我们就可以通过java程序来整合他们并生成字幕了。这里我写了个java工具，可以完成这一平时操作起来非常耗时又费劲的工作。 用法也很简单，就是选择字幕模板，字幕文件和保存路径就可以批量生成字幕了，字幕文件将保存在一个名为Titles的目录里,这样方便整个目录拷贝到PR中。值得注意的是，目前仅支持PR CC版本的字幕文件。还有就是要运行它前提是要有java运行环境。其它版本的PR，如cs,非常有空或者有兴致的时候再改下。 可以看到生成的字幕文件导入后能够正确识别,样式也和原来的模板保持一致；时间线也是按顺序来的,只要在前面导入语音识别时顺序没搞乱的话。事实上一般你在配音的时候无论用的是手机还是录音笔，都是会按照一定的顺序生成文件名的，所以一般已经不会搞乱，我的建议是都把录音都放在一个单独的文件夹里。 至此就完成了字幕的批量生成，只需用到两个工具，一个是js插件，用来获取讯飞识别出来的文本,一个是 java工具,一步到位生成字幕到指定目录。如果想直接用这两个工具的话,戳这里:密码：9o5n 如果想分析源码的话,戳这里:密码：hsgl]]></content>
      <categories>
        <category>Interesting</category>
      </categories>
      <tags>
        <tag>Clip</tag>
        <tag>Caption</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
